import stdlib

PREFIX_LENGTH = 2
STOP_WORDS = None
# Load stop words
$.get('../stop_words.txt', def(data):
    nonlocal STOP_WORDS
    STOP_WORDS = data.trim().split(RegExp('\\s+'))
)

def load_word_lists():
    texts = [
      $('#text1').val(), 
      $('#text2').val(), 
      $('#text3').val()]
    word_lists = []
    for text in texts:
        word_list = text.trim().split(RegExp('\\s+'))
        # word_list = re.split('\\s+', text) # requires ``import re``
        if len(word_list) > PREFIX_LENGTH:
            word_lists.append(word_list)
    return word_lists

def load_num_words():
    return int($('#num-words').val())

def get_words(word_lists, ratios):
    """
    Merge the list of texts according to the given ratios and
    return the resulting text split into words.
    """

    # Truncate word_lists to accord with ratios
    R = sum(ratios)
    m = Math.min(*[len(wl) for wl in word_lists])
    counts = [Math.max(PREFIX_LENGTH, Math.ceil(m*r/R)) for r in ratios]
    word_lists = [word_lists[i][:counts[i]] for i in range(len(word_lists))] 
    # Combine word lists into one word list
    result = []
    for wl in word_lists:
        result.extend(wl)
    return result

def pack(items):
    """
    Because RapydScript doesn't have ordered items :-(, 
    use item1##item2 to simulate one 
    """
    return items.join('##')

def unpack(items):
    return items.split('##')

def get_markov_analysis(words, prefix_length=PREFIX_LENGTH):
    """
    Return a Markov analysis of the list of strings ``words``.
    The output format is a dictionary with structure: 
    a tuple of contiguous words in ``words`` of length ``prefix_length`` 
    (a prefix) -> a list of all individual words in ``words`` that occur 
    after that prefix.
    """
    result = {}
    for i in range(len(words) - prefix_length):
        prefix = pack(words[i:i + prefix_length])
        suffix = words[i + prefix_length]
        if prefix in result:
            result[prefix].append(suffix)
        else:
            result[prefix] = [suffix]
    return result

def shuffle(a):
    """
    Randomly shuffle the given list and return the result.
    Uses the Fisherâ€“Yates shuffle, which is explained well at 
    http:#bost.ocks.org/mike/shuffle/ .
    """
    m = len(a) - 1

    # While there remain elements to shuffle
    while m: 
        # Pick a remaining element
        i = Math.floor(Math.random()*m)
        # And swap it with the current element
        a[m], a[i] = a[i], a[m]
        m -= 1

    return a

def choose(a):
    """
    Return a random element from the given list
    """
    i = Math.floor(Math.random()*len(a))
    return a[i]

def get_mix(words, num_words, prefix_length=2):
    """
    Return a list of ``num_words`` random words from 
    the given list of words. 
    Do this by shuffling ``d = get_markov_analysis(words, prefix_length)``,
    and traversing ``d`` until ``num_words`` random words have been 
    generated.
    """
    d = get_markov_analysis(words, prefix_length)
    # Check if d is empty. Unlike Python, you can't do ``if d`` 
    # in RapydScript
    if not len(d):
        return []

    # Shuffle prefixes
    prefixes = shuffle(dict.keys(d))
    result = unpack(prefixes[0])

    # Build num_words of random text or
    # or as many words as possible
    i = 0   
    while i < num_words:
        # Get next prefix
        prefix = pack(result[i:i + prefix_length])
        # Choose a random suffix from d[pack(prefix)]
        while prefix not in d:
            # Unlucky and got the last prefix in the source text
            # which necessarily has no suffix list.
            # So choose another prefix at random.
            prefix = choose(prefixes)
        s = d[prefix]
        suffix = choose(s)
        result.append(suffix)
        i += 1
    return result

def dump_mix(mix):
    $('#mix').val(mix)

def load_mix():
    return $('#mix').val()

def load_poem():
    return $('#poem').val()

def remove_punctuation(string):
    return string.replace(
      RegExp('[\\.,-\\/#!$%\\^&\\*;:{}=\\-_`~()@\\+\\?><\\[\\]\\+]', 'g'), '')

def validate():
    mix = remove_punctuation(load_mix().trim()).split(RegExp('\\s+'))
    mix_words = [word.toLowerCase() for word in mix
      if word not in STOP_WORDS]
    mix_stems = [stemmer(word) for word in mix_words]
    poem_words = remove_punctuation(load_poem().trim()).split(RegExp('\\s+'))
    invalid_words = []
    for word in poem_words:
        w = remove_punctuation(word.toLowerCase())
        if w in STOP_WORDS:
            continue
        if stemmer(w) not in mix_stems and word not in invalid_words:
            invalid_words.append(word)
    return invalid_words

def dump_validation(report):
    $('#validation-report').html(report)

$('#make-mix').click(def():
    $("#text1" ).effect("shake", {'times':3}, 800)
    $("#text2" ).effect("shake", {'times':3}, 1000)
    $("#text3" ).effect("shake", {'times':3}, 1200)
    setTimeout(def():
        $("#mix" ).effect("shake", {'times':1}, 800)
        print('Hello!')
        word_lists = load_word_lists()
        ratios = [1 for i in len(word_lists)]
        words = get_words(word_lists, ratios)
        print('source num words', len(words))
        num_words = load_num_words()
        print('mix num words', num_words)
        mix = get_mix(words, num_words)
        dump_mix(mix.join(' '))
    ,1000)
)        
$('#validate').click(def():
    invalid_words = validate()
    report = '<p>The following words in your poem appear to be invalid:</p>' +\
    '<textarea class="short">' + invalid_words.join(', ') + '</textarea>'
    dump_validation(report)
)
