(function(){function range(start,stop,step){if(arguments.length<=1){stop=start||0;start=0}step=arguments[2]||1;var length=Math.max(Math.ceil((stop-start)/step),0);var idx=0;var range=new Array(length);while(idx<length){range[idx++]=start;start+=step}return range}function len(obj){if(obj instanceof Array||typeof obj==="string")return obj.length;else{var count=0;for(var i in obj){if(obj.hasOwnProperty(i))count++}return count}}function _$rapyd$_in(val,arr){if(arr instanceof Array||typeof arr==="string")return arr.indexOf(val)!=-1;else{for(i in arr){if(arr.hasOwnProperty(i)&&i===val)return true}return false}}function _$rapyd$_print(){var args,output;args=[].slice.call(arguments,0);output=JSON.stringify(args);if("console"in window)console.log(output.substr(1,output.length-2))}var text;function pack(items){"\n    Because RapydScript doesn't have ordered items, \n    use item1##item2##...##itemN to simulate one \n    ";return items.join("##")}function timeit(fun){function wrap(a,b){var s;s=Date.now();a=fun(a,b);console.log(Date.now()-s);return a}return wrap}function get_markov_analysis(text,prefix_length){if(typeof prefix_length==="undefined")prefix_length=2;var words,result,prefix,suffix,i;"\n    Return a Markov analysis of the list of strings ``words``.\n    The output format is a dictionary with structure: \n    a tuple of contiguous words in ``words`` of length ``prefix_length`` \n    (a prefix) -> a list of all individual words in ``words`` that occur \n    after that prefix.\n    ";words=text.trim().split(/\s+/);result={};for(i=0;i<len(words)-prefix_length;i++){prefix=pack(words.slice(i,i+prefix_length));suffix=words[i+prefix_length];if(_$rapyd$_in(prefix,result)){result[prefix].push(suffix)}else{result[prefix]=[suffix]}}return result}get_markov_analysis=timeit(get_markov_analysis);text=$("body").text();_$rapyd$_print(len(text));get_markov_analysis(text)})();